---
title: "VPC simulations"
output:
rmarkdown::html_vignette:
    toc: true
Suggests: markdown
VignetteBuilder: knitr
vignette: >
  %\VignetteIndexEntry{02VPC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
- \usepackage{ae}
---

```{r,include = FALSE}
library(tidyvpc)
library(NMdata)
library(fst)
##knitr::opts_chunk$set(dev = "cairo_pdf")
knitr::opts_chunk$set(
                      collapse = TRUE
                     ,comment = "#>"
                     ,fig.width=7
                     ,cache=FALSE
                  )

## NMdataConf(dir.psn="/opt/psn")

## this changes data.table syntax. I think we can do without.
## knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy=TRUE)
run.simuls <- FALSE
```

## Simulations for Visual Predictive Checks (VPC)
This vignette shows how to generate simulations for generation of VPC
plots. While `NMsim` does not include any functionality for summarizing quantiles or plotting, it provides powerful ways to obtain the simulated data needed. We shall see how the `tidyvpc` package easily creates VPC plots based on the simulation results.

## Default option: reuse estimation data for simulation
Normally, the two main arguments to NMsim are the path to the input
control stream (`file.mod`) and the simulation input data set
(`data`). But if we leave out the the `data` argument, NMsim will
re-use the estimation data for the simulation. That is the simulation
we need for a VPC. We will use an example model included with NMsim:

```{r,eval=TRUE}


file.project <- function(...)file.path(system.file("examples",package="NMsim"),...)
file.mod <- file.project("nonmem/xgxr032.mod")

```

```{r,eval=FALSE}
set.seed(43)
## notice the data argument is not used.
simres.vpc <- NMsim(file.mod,
                    table.vars=c("PRED","IPRED", "Y"),
                    dir.sims="testOutput",
                    name.sim="vpc_01"
                   ,nsims=500
                    )

```

Similar to PSN VPC

Simulation results automatically read into R

Allows for `table.vars`

Simulation with modified input uses same code

### Make use of the cluster
We will repeat the same as above, but now 500 times (`nsims`). We make
use of a few more arguments for efficiency. `sge` means that the jobs
will be sent to the cluster. The `nc` argument is now used meaning
only one core will be used per job. If each node on the cluster has 16
cores, this could engage 500/16 ~ 32 nodes in parallel, with all jobs
executed at the same time. We supply the path to the Nonmem executable. With PSN this should work without specifying the Nonmem path, but PSN for some reason takes more time submitting the jobs to the cluster. If nodes are available, the following simulation should not take more than a couple of minutes to execute.

```{r,eval=TRUE}
file.project <- function(...)file.path(system.file("examples",package="NMsim"),...)
file.mod <- file.project("nonmem/xgxr032.mod")
file.res="simulate-results/simpaths-vpc.rds"
```

```{r,eval=FALSE}
set.seed(43)
## notice the data argument is not used.
sim.vpc.sge <- NMsim(file.mod,
                     table.vars=c("PRED","IPRED", "Y"),
                     dir.sims="testOutput",
                     name.sim="vpc_01"
                    ,nsims=500
                    ,sge=TRUE
                    ## ,path.nonmem="/opt/nonmem/nm751/run/nmfe75"
                    ,path.nonmem="/opt/NONMEM/nm75/run/nmfe75"
                    ,file.res=file.res
                     )

```

```{r,include=FALSE,eval=TRUE}
simres.vpc <- NMreadSim(file.res)
```



## Plotting using `tidyvpc` 
```{r}
res <- NMscanData(file.mod,as.fun="data.table")
data.obs <- res[EVID==0]


## run vpc
vpc1 <-
    observed(data.obs[EVID==0], x = TIME, y = DV) |>
    simulated(simres.vpc[EVID==0], y = Y) |>
    stratify(~DOSE) |>
    binning(bin = "ntile", nbins = 9) |>
    vpcstats()


plot(vpc1)

```
