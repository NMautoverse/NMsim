


NMreadSimModTab <- function(x,...){

    res.list <- lapply(x,NMreadSimModTabOne,...)
    res <- rbindlist(res.list,fill=TRUE)

    res

}

NMreadSimModTabOne <- function(x,check.time=FALSE,dir.sims,wait=FALSE,quiet=FALSE){

        if(is.character(x)) {
        ##  an rds, read it, make sure its NMSimModels, check for fst,  and proceed with NMSimModels
        
        tab.paths.list <- lapply(x,function(file){
            tab.paths <- readRDS(file)
            if(!inherits(tab.paths,"NMsimModTab")) {
                if(!is.data.frame(tab.paths)){
                    stop("The provided rds file does not contain a NMsimModTab object")
                }
                message("x is not a NMsimModTab object. This can be OK if it was generated using earlier versions of NMsim. However, you may need to provide `dir.sims` for this to work.")
            }
            tab.paths[,path.rds.read:=file]
        })

        tab.paths <- rbindlist(tab.paths.list,fill=TRUE)
        file.res.data <- fnAppend(fnExtension(x,"fst"),"res")


####### TODO this must be by row!!
### if we have an fst, read it and return results
        if(!is.null(file.res.data) &&
           file.exists(file.res.data) ){
            time.ok <- TRUE
            if(check.time){
                time.ok <- file.mtime(file.res.data)>file.mtime(x)
            }
            if(time.ok){
                res <- read_fst(file.res.data,as.data.table=TRUE)
                addClass(res,"NMsimRes")
                ## return(as.fun(res))
                return(res)
            } 
        }
    } else if(is.NMsimModTab(x)){
        ## a NMSimModels already, go to procecssing that
        tab.paths <- x
    } else if (is.NMsimRes(x)){
        ## NMsimRes - nothing to do at all
        return(x)
    } else {
        stop("x is not recognized as being associated with NMsim. NMreadSim is only intended for reading output generated by NMsim.")
    }
    
####### Now we have a NMSimModels object to process.
    
### will need a function to apply transformations if applicable
    wrap.trans <- function(dt,...){
        funs <- list(...)
        for(name.fun in names(funs)){
            dt[,(name.fun):=funs[[name.fun]](get(name.fun))]
        }
        dt
    }

### read all sim results

####  must read each model into list elements. Then rbind(fill=T)
### this is to make sure results from different models with
### incompatible columns can be combined.
    
    ## add in usable path to sim results
    tab.paths[,ROWTMP:=.I]
    tab.paths[,path.lst.read:={
        if(is.null(dir.sims)){
            dirSims <- file.path(dirname(path.rds.read),pathSimsFromRes)
        } else {
            dirSims <- dir.sims           
        }
        file.path(dirSims,relative_path(path.sim.lst,dirSims))
    },
    ## by=.(ROWMODEL2)
    by=.(ROWTMP)
    ]

    
    if(wait){
        done <- all(file.exists(tab.paths[,path.lst.read]))
        turns <- 0
        if(!done) message("Waiting for Nonmem to finish simulating...")
        while(!done){
            Sys.sleep(5)
            done <- all(file.exists(tab.paths[,path.lst.read]))
            turns <- turns+1
        }
        if(turns>0) message("Nonmem finished.")
    }
    
    
    res.list <- lapply(split(tab.paths,by="ROWMODEL2"),function(dat){
        res <- dat[,{
            ## cat(ROWMODEL2," ")     
            ## the rds table must keep NMscanData arguments
            args.NM <- args.NMscanData[[1]]
            if(! "quiet" %in% names(args.NM)){
                args.NM$quiet <- TRUE
            }
            
            ## this.res <- do.call(NMscanData,c(list(file=file.path(dirname(pathResFromSims),pathResFromSims,relative_path(path.sim.lst,dirname(pathResFromSims)))),args.NM))

            ## this.res <- do.call(NMscanData,
            ##                     c(list(
            ##                         file=file.path(dirname(x),pathSimsFromRes,relative_path(path.sim.lst,dirname(x)))),args.NM))

            ## this works, but moving it outside
            if(FALSE){
                if(!is.null(dir.sims)){
                    dirSims <- dir.sims
                } else {
                    dirSims <- file.path(dirname(x),pathSimsFromRes)
                }
                this.res <- do.call(NMscanData,
                                    c(list(
                                        file=file.path(dirSims,relative_path(path.sim.lst,dirSims))),args.NM))
            }
            ## put this in try and report better info if broken
            this.res <- try(do.call(NMscanData,
                                    c(list(file=path.lst.read),args.NM)
                                    ))
            if(inherits(this.res,"try-error")){
                if(!quiet) {
                    lines.lst <- readLines(path.lst.read)
                    nlines <- length(lines.lst)
                    message("Results could not be read from %s\nPasting the bottom of outputput control stream:\n",path.lst.read,paste(lines.lst[(nlines-25):nlines],collapse="\n"))
                }
                this.res <- NULL
            }

            if(!is.null(.SD$funs.transform)){
                this.funs <- .SD[1,funs.transform][[1]]
                this.res <- do.call(wrap.trans,c(list(dt=this.res),this.funs))
                this.res
            }


            this.res
        },by=.(ROWMODEL2)]


    })
    
    res <- rbindlist(res.list,fill=TRUE)
    res[,ROWMODEL2:=NULL]

    if(!is.null(file.res.data)){
        NMwriteData(res,
                    file=file.res.data,
                    formats.write="fst",
                    genText=F,
                    quiet=TRUE)
    }

    
    setattr(res,"NMsimModTab",tab.paths)
    addClass(res,"NMsimRes")
    res

}
